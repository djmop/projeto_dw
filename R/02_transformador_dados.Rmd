---
title: "Transformação de dados - Projeto BI (PUC)"
author: "Daniel T. Nunes"
date: "2022-09-11 03:00"
output:
  rmdformats::downcute:
    embed_fonts: yes
    use_bookdown: yes
    default_style: dark
    downcute_theme: chaos
  html_document:
    df_print: paged
  pdf_document: default
editor_options:
  chunk_output_type: console
---

# Transformação de dados - Projeto BI (PUC)

```{r importa.pacotes, message=FALSE}

library(stringr)
library(tibble)
library(dplyr)
library(readr)
library(purrr)
library(tidyr)

library(lubridate)
library(janitor)
library(glue)

library(magrittr)
library(here)

```

## Carregamento

```{r funcoes.carregamento}

load.csvs <- function(dir.paths) {
  csvs <- list()
  
  for (dir.path in dir.paths) {
    dir.name <- basename(dir.path)
    csv.files <- fs::dir_ls(
      here(dir.path),
      type = 'file',
      glob = '*.csv'
    )
    
    logs <- list(e = list(), w = list())
    
    tryCatch(
      expr = {
        cli::cli_process_start(glue::glue("Leitura de csvs: `{dir.name}`"))
        
        csv.dfs <- map(
          csv.files,
          ~read_delim(
            .,
            delim          = ';',
            locale         = locale(encoding = 'latin1'),
            show_col_types = FALSE,
            progress       = FALSE,
            col_types      = cols(.default = col_character()),
            name_repair    = 'minimal'
          )
        )
        
        csv.dfs <- map(csv.dfs, ~janitor::clean_names(.[]))
        names(csv.dfs)   <- basename(str_remove(csv.files, r'{\.csv}'))
        csvs[[dir.name]] <- csv.dfs
        
        cli::cli_process_done()
      },
      error = function(e) {
        cli::cli_process_failed()
        i <- length(logs$e) + 1
        logs$err[[i]] <- e
      },
      
      warning = function(w) {
        j <- length(logs$w) + 1
        logs$wrn[[j]] <- w
      }
    )
  }
  
  return(list(log = logs, data = csvs))
}

```

```{r carrega.csvs, message=FALSE}

dir.paths <- fs::dir_ls(here('raw_data'), type = 'directory')
csvs <- load.csvs(dir.paths)

detach("package:readr", unload=TRUE)

```

## Transformação

### [Organizando variações estruturais]{.smallcaps}

```{r funcoes.de.agrupamento}

#' Create sets of data.frames with identical column names.
#' 
#' @description Data.frames comprising identical column names and
#'   column order are put into the same set for further treatment.
#' @param x List of data.frames.
#' @return List of grouped data.frames with identical columns.
#' 
group_by_cols <- function(x) {
  assertthat::assert_that(every(x, is.data.frame))
  
  col.sets <- list()
  df.sets  <- list()
  
  s = 0
  for (i in seq_along(x)) {
    df <- x[[i]]
    col.set <- keep(col.sets, ~ identical(., colnames(df)))
    
    if (length(col.set) == 0) {
      s = s + 1
      col.set.nm <- glue("S{s}")
      col.sets[[col.set.nm]] <- colnames(df)
    } else {
      col.set.nm <- names(col.set)
    }
    
    df.nm <- names(x[i])
    df.sets[[col.set.nm]][[df.nm]] <- df
  }
  return(df.sets)
}

```

```{r funcoes.de.analise, include=FALSE}

#' Create sets of unique column names.
#' @param x List of data.frames.
#' @return List of unique column sets.
#' 
unique_col_sets <- function(x) {
  assertthat::assert_that(every(x, is.data.frame))
  colnms <- map(x, colnames)
  col.sets <- list()
  i = 0
  for (cn in colnms) {
    set.exists <- some(col.sets, ~ identical(., cn))
    if (set.exists) { next }
    i = i + 1
    col.sets[[glue("S{i}")]] <- cn
  }
  
  return(col.sets)
}

#' Compute the assymetric difference among columns of dataframes.
#' @description Calculates the number of differences found in
#'   column names with `setdiff`.
#' @param x List of data.frames.
#' @return Matrix of assymetric differences.
#' 
compare_cols <- function(x) {
  col.sets <- unique_col_sets(x)
  len <- length(col.sets)
  nms <- names(col.sets)

  comp.df <- tibble(
    A      = character(),
    B      = character(),
    union  = integer(),
    intsc  = integer(),
    diffs  = list(list(AB = character(), BA = character()))
  )

  comparisons <- list()

  for (i in 1:len) {
    for (j in 1:len) {
      skip <- i == j | some(comparisons, ~setequal(., c(i, j)))
      if (skip) { next }
      comparisons %<>%
        append(list(c(i,j)))
      
      a <- col.sets[[i]]
      b <- col.sets[[j]]
      
      comp.df %<>% add_row(
        A     = nms[i],
        B     = nms[j],
        union = length(union(a, b)),
        intsc = length(intersect(a, b)),
        diffs = list(list(AB = setdiff(a, b), BA = setdiff(b, a)))
      )
    }
  }
  return(comp.df)
}

col.sets <- map(csvs$data, unique_col_sets)

```

```{r agrupa.por.atributos, message=FALSE}

##  Concatena datasets comuns
##  -------------------------
df.sets <- map(csvs$data, group_by_cols)
df.sets <- map(df.sets, ~map(., bind_rows, .id = "arquivo_original"))

```

```{r libera.memoria, include=FALSE}

##  Libera memória
##  --------------
rm(csvs)
gc()

```

```{r declara.output}

output <- list()

```

### [Transformação estrutural por dataset]{.smallcaps}

```{r transf.est.logradouros}

dataset <- df.sets$logradouros

##  Dicionários
##  -----------
dataset$S1 %<>% rowwise() %>%
  mutate(nome_do_arquivo = make_clean_names(nome_do_arquivo)) %>%
  ungroup()

output[['logradouros']][['dict']] <- dataset$S1
dataset['S1'] <- NULL


##  Conversão de nomes de campos
##  ----------------------------
kpitoolkit::compare_colnames(dataset, sort = TRUE)

conversions <- c(
  data_hora_boletim        = 'data_boletim',
  num_bairro               = 'no_bairro',
  num_boletim              = 'no_boletim',
  num_imovel               = 'no_imovel',
  num_imovel_proximo       = 'no_imovel_proximo',
  num_logradouro           = 'no_logradouro',
  num_municipio            = 'no_municipio',
  num_bairro               = 'numero_bairro',
  num_boletim              = 'numero_boletim',
  num_imovel               = 'numero_imovel',
  num_imovel_proximo       = 'numero_imovel_proximo',
  num_logradouro           = 'numero_logradouro',
  num_municipio            = 'numero_municipio',
  nome_logradouro_anterior = 'nome_logradoro_anterior',
  sequencia_logradouros    = 'seq_logradouros'
)

dataset <- map(dataset, ~ rename(., any_of(conversions)))

kpitoolkit::compare_colnames(dataset, sort = TRUE)



##  Fusão de tabelas
##  ----------------
dataset %<>% bind_rows()

output[['logradouros']][['data']] <- dataset

```

```{r transf.est.ocorrencias}

dataset <- df.sets$ocorrencias

##  Dicionários
##  -----------
dataset$S1 %<>% rowwise() %>%
  mutate(nome_do_arquivo = make_clean_names(nome_do_arquivo)) %>%
  ungroup()

##  Conversão de nomes de campos
##  ----------------------------
conversions <- c(
  num_boletim = 'numero_boletim',
  desc_ups    = 'descricao_ups'
)

dataset[['S2']] %<>% rename(any_of(conversions))

output[['ocorrencias']][['dict']] <- dataset$S1
output[['ocorrencias']][['data']] <- dataset$S2

```

```{r transf.est.pessoas}

dataset <- df.sets$pessoas_envolvidas

##  Dicionários
##  -----------
dataset$S1 %<>% rowwise() %>%
  mutate(nome_do_arquivo = make_clean_names(nome_do_arquivo)) %>%
  ungroup()

output[['pessoas_envolvidas']][['dict']] <- dataset$S1
dataset['S1'] <- NULL


##  Conversão de nomes de campos
##  ----------------------------
kpitoolkit::compare_colnames(dataset, sort = TRUE)

conversions <- c(
  num_envolvido    = 'no_envolvido',
  num_envolvido    = 'numero_envolvido',
  passageiro       = 'indicador_passageiro',
  passageiro       = 'passageiro',
  pedestre         = 'indicador_pedestre',
  pedestre         = 'pedestre',
  cod_severidade   = 'codigo_severidade',
  usa_capacete     = 'indicador_usa_capacete',
  num_boletim      = 'no_boletim',
  desc_habilitacao = 'descricao_habilitacao'
)

dataset <- map(dataset, ~ rename(., any_of(conversions)))

kpitoolkit::compare_colnames(dataset, sort = TRUE)


##  Fusão de tabelas
##  ----------------
dataset %<>% bind_rows()

output[['pessoas_envolvidas']][['data']] <- dataset

```

```{r transf.est.veiculos}

dataset <- df.sets$veiculos_envolvidos

##  Dicionários
##  -----------
dataset$S1 %<>% rowwise() %>%
  mutate(nome_do_arquivo = make_clean_names(nome_do_arquivo)) %>%
  ungroup()

output[['veiculos_envolvidos']][['dict']] <- dataset$S1
dataset['S1'] <- NULL


##  Conversão de nomes de campos
##  ----------------------------
kpitoolkit::compare_colnames(dataset, sort = TRUE)

conversions <- c(
  num_boletim        = 'no_boletim',
  num_boletim        = 'numero_boletim',
  cod_categoria      = 'cod_categ',
  cod_categoria      = 'codigo_categoria',
  cod_situacao       = 'cod_situacao',
  cod_situacao       = 'codigo_situacao',
  cod_especie        = 'cod_especie',
  cod_especie        = 'codigo_especie',
  desc_situacao      = 'desc_situacao',
  desc_situacao      = 'descricao_situacao',
  desc_tipo_socorro  = 'descricao_tipo_socorro',
  desc_categoria     = 'descricao_categoria',
  desc_especie       = 'descricao_especie',
  sequencial_veiculo = 'seq_veic'
)

dataset <- map(dataset, ~ rename(., any_of(conversions)))

kpitoolkit::compare_colnames(dataset, sort = TRUE)


##  Fusão de tabelas
##  ----------------
dataset %<>% bind_rows()

output[['veiculos_envolvidos']][['data']] <- dataset

```

```{r limpa.est.ambiente, include=FALSE}

rm(df.sets, dataset, load.csvs, group_by_cols, unique_col_sets, compare_cols)
rm(conversions, dir.paths, col.sets)

```

### [Transformação de valores]{.smallcaps}

```{r transf.valores}

output <- map(output, ~map(., mutate, across(.fns = str_squish)))

```

<br />

#### [*Logradouro*]{.smallcaps}

1.  **Validação de tipos**

```{r logr}

dct <- output$logradouros$dict
aux <- readr::type_convert(output$logradouros$data)

# x <- map(aux, ~sort(unique(.)))
# y <- map(x, ~ if (length(.) > 30) {sample(., 30)} else {.})
# rm(x, y)

```

3.  **Resultados**

-   *Campos inconsistentes ou desnecessários:*

+-------------------------------------------------------+-------------------------------------------------------------------------+--------------------------------------+-------------+
| Campo                                                 | Notas                                                                   | Solução                              | Fixed       |
+=======================================================+=========================================================================+======================================+:===========:+
| `num_imovel`                                          | Campo livre para digitação (irregular)                                  | won't fix                            | won't fix   |
+-------------------------------------------------------+-------------------------------------------------------------------------+--------------------------------------+-------------+
| `num_municipio`                                       | Campo contém apenas um valor                                            | Remoção do campo                     | x           |
|                                                       |                                                                         |                                      |             |
|                                                       | `(1 = BELO HORIZONTE)`                                                  |                                      |             |
+-------------------------------------------------------+-------------------------------------------------------------------------+--------------------------------------+-------------+
| `desc_tipo_bairro` , `nome_logradouro`, `nome_bairro` | Valores inconsistentes                                                  | Padronização para                    | x           |
|                                                       |                                                                         |                                      |             |
|                                                       | `["NÃO INFORMADO", "Nï¿½O INFORMADO"]`                                  | `NAO INFORMADO`                      |             |
+-------------------------------------------------------+-------------------------------------------------------------------------+--------------------------------------+-------------+
| `desc_tipo_log`                                       | Não existe descrição para logradouro (Existe em outra tabela?)          | Gerado a partir de dados pesquisados | x           |
+-------------------------------------------------------+-------------------------------------------------------------------------+--------------------------------------+-------------+
| `num_imovel_proximo`                                  | Não há dados úteis. Obs.: unique do campo retorna os seguintes valores: | Remoção do campo                     | x           |
|                                                       |                                                                         |                                      |             |
|                                                       | `["0", "0 ,", "0,"]`                                                    |                                      |             |
+-------------------------------------------------------+-------------------------------------------------------------------------+--------------------------------------+-------------+

4.  **Fix**

```{r fix.fatores.logr}

aux %<>% mutate(data_hora_boletim = parse_date_time(
  data_hora_boletim, '%d/%m/%Y %H:%M'
))

aux %<>% mutate(across(
  c(
    descricao_tipo_bairro,
    nome_logradouro,
    nome_bairro
  ),
  ~case_when(
    str_detect(., 'N.+O INFORMADO') ~ 'NAO INFORMADO',
    TRUE ~ .
  )
))

aux %<>% mutate(across(
  c(
    descricao_tipo_bairro,
    nome_logradouro,
    nome_bairro
  ),
  ~stringi::stri_trans_general(str = ., id = "Latin-ASCII")
))

##  Source: https://fazenda.pbh.gov.br/iss/cmc/forms.htm
##  ----------------------------------------------------
aux %<>% mutate(across(
  tipo_logradouro,
  ~ case_when(
    . == 'ACS' ~ 'ACESSO',
    . == 'ALA' ~ 'ALAMEDA',
    . == 'AVE' ~ 'AVENIDA',
    . == 'BEC' ~ 'BECO',
    . == 'CAM' ~ 'CAMINHO',
    . == 'ELV' ~ 'ELEVADO',
    . == 'ELP' ~ 'ESPACO LIVRE PARA PEDESTRE',
    . == 'EST' ~ 'ESTRADA',
    . == 'MAR' ~ 'MARGINAL',
    . == 'PCA' ~ 'PRACA',
    . == 'QTF' ~ 'QUARTEIRAO FECHADO',
    . == 'RDP' ~ 'RUA DE PEDESTRE',
    . == 'RMA' ~ 'REDE DE MANILHAS',
    . == 'ROD' ~ 'RODOVIA',
    . == 'RTN' ~ 'RETORNO',
    . == 'RUA' ~ 'RUA',
    . == 'TRE' ~ 'TREVO',
    . == 'TRI' ~ 'TRINCHEIRA',
    . == 'TRV' ~ 'TRAVESSA',
    . == 'TUN' ~ 'TUNEL',
    . == 'VDP' ~ 'VIA DE PEDESTRE',
    . == 'VDT' ~ 'VIADUTO',
    . == 'VIA' ~ 'VIA'
  ),
  .names = 'desc_tipo_logradouro'
))


aux %<>% select(-num_municipio, -num_imovel_proximo)



##  REMOVENDO DUPLICATAS
##  --------------------
aux %<>% distinct()



##  SALVANDO ALTERAÇÕES
##  -------------------
output$logradouros$data <- aux

```

<br />

#### [*Ocorrências*]{.smallcaps}

1.  **Validação de tipos**

```{r ocor}

dct <- output$ocorrencias$dict
aux <- readr::type_convert(output$ocorrencias$data)

# x <- map(aux, ~sort(unique(.)))
# y <- map(x, ~ if (length(.) > 30) {sample(., 30)} else {.})
# rm(x, y)

```

3.  **Resultados**

-   *Campos inconsistentes ou desnecessários:*

+-------------------------------------------------------------------+-------------------------------------------------------------+-----------------+-----------+
| Campo                                                             | Notas                                                       | Solução         | Fixed     |
+===================================================================+=============================================================+=================+:=========:+
| `origem_boletim`                                                  | Valores trimados: `["CORPO DE BOMBEI", "POLICIA RODOVIA"]`  | completar nomes | x         |
+-------------------------------------------------------------------+-------------------------------------------------------------+-----------------+-----------+
| `local_sinalizado`, `hora_informada`, `descricao_ups`             | Acentos: `["NÃO", "NÃO INFORMADO"]`                         | remover acentos | x         |
+-------------------------------------------------------------------+-------------------------------------------------------------+-----------------+-----------+
| `coordenada_x`, `coordenada_y`                                    | Missing datas: `["0000000000.00"]`                          | alterar para NA | x         |
+-------------------------------------------------------------------+-------------------------------------------------------------+-----------------+-----------+
| `data_alteracao_smsa`, `valor_ups_antiga`, `descricao_ups_antiga` | Inexistem valores: `"00/00/0000"` , `0` , `"NÃO INFORMADO"` | remover campos  | x         |
+-------------------------------------------------------------------+-------------------------------------------------------------+-----------------+-----------+
| `coordenada_x`, `coordenada_y`                                    | Leading zero: `["0061011635.00", …,  "0060770301.00"]`      | won't fix       | won't fix |
+-------------------------------------------------------------------+-------------------------------------------------------------+-----------------+-----------+
| `desc_regional`                                                   | Apresenta `3473` missing data                               | won't fix       | won't fix |
+-------------------------------------------------------------------+-------------------------------------------------------------+-----------------+-----------+

4.  **Fix**

```{r fix.fatores.ocor}

aux %<>% mutate(across(
  c(data_hora_boletim, data_inclusao),
  ~ parse_date_time(., '%d/%m/%Y %H:%M')
))


aux %<>% mutate(across(
  c(
    hora_informada,
    desc_tipo_acidente,
    origem_boletim,
    indicador_fatalidade,
    local_sinalizado,
    desc_ups
  ),
  ~stringi::stri_trans_general(str = ., id = "Latin-ASCII")
))

aux %<>% mutate(across(
  c(origem_boletim),
  ~ case_when(
    . == "CORPO DE BOMBEI" ~ 'CORPO DE BOMBEIROS',
    . == "POLICIA RODOVIA" ~ 'POLICIA RODOVIARIA',
    . == 'NI' ~ 'NAO INFORMADO',
    TRUE ~ .
  )
))

aux %<>% mutate(across(
  c(desc_regional),
  ~ case_when(
    cod_regional == 0 ~ 'NAO INFORMADO',
    TRUE ~ .
  )
))

aux %<>% select(
  -data_alteracao_smsa,
  -valor_ups_antiga,
  -descricao_ups_antiga
)

aux %<>% mutate(across(
  c(coordenada_x, coordenada_y),
  ~case_when(
    . == '0000000000.00' ~ NA_character_,
    TRUE ~ .
  )
))

aux$velocidade_permitida %<>% na_if(., 0)


##  REMOVENDO DUPLICATAS
##  --------------------
aux %<>% distinct()



##  SALVANDO ALTERAÇÕES
##  -------------------
output$ocorrencias$data <- aux

```

<br />

#### [*Pessoas envolvidas*]{.smallcaps}

1.  **Validação de tipos**

```{r pess}

dct <- output$pessoas_envolvidas$dict
aux <- readr::type_convert(output$pessoas_envolvidas$data)

# x <- map(aux, ~sort(unique(.)))
# y <- map(x, ~ if (length(.) > 30) {sample(., 30)} else {.})
# rm(x, y)

```

3.  **Resultados**

-   *Campos inconsistentes ou desnecessários:*

+-----------------------------------------------------------------------+--------------------------------------------------------------------------+---------------------------------------+------------+
| Campo                                                                 | Notas                                                                    | Solução                               | Fixed      |
+=======================================================================+==========================================================================+=======================================+:==========:+
| `condutor`, `pedestre`, `passageiro`, `cinto_seguranca`, `embreagues` | Acentos                                                                  | Remover acentos                       | x          |
+-----------------------------------------------------------------------+--------------------------------------------------------------------------+---------------------------------------+------------+
| `usa_capacete`, `x`, `declaracao_obito`, `cod_severidade_antiga`      | Sem valores                                                              | Remover campos                        | x          |
+-----------------------------------------------------------------------+--------------------------------------------------------------------------+---------------------------------------+------------+
| `condutor`, `pedestre`, `passageiro`                                  | Sem padrão                                                               | Padronizar valores                    | x          |
|                                                                       |                                                                          |                                       |            |
|                                                                       | `["0", "N", "NÃO", "NÃO INFORMADO", "S", "SIM"]`                         |                                       |            |
+-----------------------------------------------------------------------+--------------------------------------------------------------------------+---------------------------------------+------------+
| `sexo`                                                                | Missing data `"0"`                                                       | Alterar para NA                       | x          |
+-----------------------------------------------------------------------+--------------------------------------------------------------------------+---------------------------------------+------------+
| `idade`, `nascimento`                                                 | Missing data `"0"`, `"00/00/0000"`                                       | `["0", "00/00/0000"]` -\> ambos NA    | x          |
|                                                                       |                                                                          |                                       |            |
|                                                                       | Obs.: Alguns casos apresentam idade sem data de nascimento e vice-versa. | `[<valor>, "00/00/0000"]` -\> nasc NA |            |
|                                                                       |                                                                          |                                       |            |
|                                                                       |                                                                          | `["0", <valor>]` -\> calcular idade   |            |
+-----------------------------------------------------------------------+--------------------------------------------------------------------------+---------------------------------------+------------+
| `idade` , `nascimento`                                                | Valores incompatíveis ou inconsistentes                                  | Alterar para NA                       | x          |
+-----------------------------------------------------------------------+--------------------------------------------------------------------------+---------------------------------------+------------+

4.  **Fix**

```{r fix.fatores.pess}

##  REMOÇÃO DE CAMPOS SEM DADOS
##  ---------------------------
aux %<>% select(-c(
  usa_capacete,
  x
))


##  REMOÇÃO DE ACENTOS
##  ------------------
aux %<>% mutate(across(
  c(
    condutor,
    pedestre,
    passageiro,
    cinto_seguranca,
    embreagues
  ),
  ~stringi::stri_trans_general(str = ., id = "Latin-ASCII")
))


##  PADRONIZAÇÃO
##  ------------
aux %<>% mutate(across(
  c(condutor, pedestre, passageiro, cinto_seguranca, embreagues),
  ~ case_when(
    . == '0' | . == 'NAO INFORMADO' | is.na(.) ~ 'NI',
    . == 'N' ~ 'NAO',
    . == 'S' ~ 'SIM',
    TRUE ~ .
  )
))

aux %<>% mutate(across(
  c(categoria_habilitacao),
  ~ case_when(
    desc_habilitacao == 'NAO SE APLICA' ~ 'NA',
    . == 'N' | is.na(.) ~ 'NI',
    TRUE ~ .
  )
))

aux %<>% mutate(across(
  c(desc_habilitacao),
  ~ case_when(
    is.na(.) ~ 'NAO INFORMADO',
    TRUE ~ .
  )
))

aux %<>% mutate(across(
  c(especie_veiculo),
  ~ case_when(
    is.na(.) ~ 'NAO INFORMADO',
    TRUE ~ .
  )
))


##  SEXO
##  ----
aux %<>% mutate(across(
  c(sexo),
  ~ case_when(
    not(. %in% c('M', 'F')) ~ '0',
    TRUE ~ .
  )
))


##  AJUSTE DATAS
##  ------------
aux %<>% mutate(across(data_hora_boletim, ~parse_date_time(., '%d/%m/%Y %H:%M')))

aux$nascimento %<>% na_if(., '00/00/0000')

aux %<>% mutate(across(nascimento, ~dmy(.)))


##  AJUSTE DE IDADE E DATA DE NASCIMENTO
##  ------------------------------------
aux %<>% mutate(across(
  idade,
  ~case_when(
    . == '0' & is.na(nascimento) ~ NA_real_,
    TRUE ~ .
  )
))

aux %<>% mutate(
  idade_new = as.duration(
    interval(nascimento, lubridate::date(data_hora_boletim))
  ) %/% dyears()
) %>% relocate(idade_new, .after = idade)

aux %<>% mutate(
  idade_diff = idade_new - idade
) %>% relocate(idade_diff, .after = idade_new)

aux %<>% mutate(across(
  nascimento,
  ~ case_when(
    is.na(idade_new) | is.na(idade_diff) ~ .,
    idade_new < 0 | idade_new > 125 ~ NA_Date_,
    TRUE ~ .
  )
))

aux %<>% mutate(across(
  idade_new,
  ~ case_when(
    is.na(idade_new) | is.na(idade_diff) ~ .,
    idade_new < 0 | idade_new > 125 ~ NA_real_,
    TRUE ~ .
  )
))

aux %<>% select(-idade, -idade_diff)
aux %<>% rename(idade = idade_new)


##  REMOVENDO DUPLICATAS
##  --------------------
aux %<>% distinct()



##  SALVANDO ALTERAÇÕES
##  -------------------
output$pessoas_envolvidas$data <- aux

```

<br />

#### [*Veículos envolvidos*]{.smallcaps}

1.  **Validação de tipos**

```{r veic}

dct <- output$veiculos_envolvidos$dict
aux <- readr::type_convert(output$veiculos_envolvidos$data)

# x <- map(aux, ~sort(unique(.)))
# y <- map(x, ~ if (length(.) > 30) {sample(., 30)} else {.})
# rm(x, y)

```

3.  **Resultados**

-   *Campos inconsistentes ou desnecessários:*

+------------------------------------------------------------------------+------------------------+-----------------+----------+
| Campo                                                                  | Notas                  | Solução         | Fixed    |
+========================================================================+========================+=================+:========:+
| `desc_categoria`, `desc_especie`, `desc_situacao`, `desc_tipo_socorro` | Presença de acentuação | Remover acentos | x        |
+------------------------------------------------------------------------+------------------------+-----------------+----------+

4.  **Fix**

```{r fix.fatores.veic}

##  REMOÇÃO DE ACENTOS
##  ------------------
aux %<>% mutate(across(
  c(
    desc_categoria,
    desc_especie,
    desc_situacao,
    desc_tipo_socorro
  ),
  ~stringi::stri_trans_general(str = ., id = "Latin-ASCII")
))


##  AJUSTANDO TIPO DATA
##  -------------------
aux %<>% mutate(across(
  c(data_hora_boletim),
  ~ parse_date_time(., '%d/%m/%Y %H:%M')
))


##  REMOVENDO DUPLICATAS
##  --------------------
aux %<>% distinct()



##  SALVANDO ALTERAÇÕES
##  -------------------
output$veiculos_envolvidos$data <- aux

```

### [Salvando transformação]{.smallcaps}

```{r salvamento}

if (!dir.exists(here('data'))) {
  dir.create(here('data'))
}

for (i in seq_along(output)) {
  dt <- output[[i]]$data
  nm <- names(output)[i]
  readr::write_csv(dt, here('data', glue('{nm}.csv')))
}


```

### [Liberando memória]{.smallcaps}

```{r libera.memoria.finalizacao}

rm(list = ls())

purrr::walk(
  names(sessionInfo()$otherPkgs), 
  ~ detach(
    paste0('package:', .),
    character.only = TRUE,
    unload = TRUE,
    force = TRUE
  )
)

rstudioapi::restartSession()

```
